\documentclass[parskip=half]{scrartcl}

\title{VeriDum: Computing SL+ and ISL+ Postconditions via Symbolic Execution}
\subtitle{LIS project report}
\date{2025-06-xx}
\author{ % random order
  Massimiliano Baglioni      \and
  Salvatore Salerno          \and
  Anna Francesca Montagnoli  \and
  Sofia Pisani               \and
  Lorenzo Pace               \and
  Jhonatan Azevedo Gonçalves \and
  Alessio Duè                \and
  Pamela Di Clemente         \and
  Emanuele Buonaccorsi}

\input{preamble.tex}

\begin{document}

\maketitle

\begin{abstract}
  We present a tool to compute SL+ and ISL+ postconditions.
\end{abstract}

\section{Dummy stuff}

brief description of the logic and its rules

\section{Symbolic execution}

Given a precondition and a program, we produce a postcondition by means of symbolic execution. The program is executed step by step, using the postcondition of a command as the precondition of the next.

\subsection{Executor state}

During symbolic execution, the logical proposition that is currently known to hold (\ie the postcondition of the previous command or initial precondition) is kept in a normal form with the following shape:
\begin{align*}
  &x = x' \wedge y = y' \wedge \dots \\
  &\wedge (x' \mapsto a_1 \ast x'' \mapsto a_2 \ast \dots \ast y' \mapsto b_1 \ast y'' \mapsto b_2 \ast \dots) \\
  &\wedge p
\end{align*}
\ie a single equality between each program variable and a dummy variable, the heap with possibly a chunk for each dummy variable (but not for program variables), and a path condition \(p\). The path condition is a conjunction of comparisons and boolean constants, and cannot contain program variables.

In OCaml, this is implemented as (\texttt{executor\_state.ml}):
\begin{minted}{ocaml}
  type heapval =
    | Val of Aexp.t (* x ↦ e *)
    | Undefined     (* x ↦ _ *)
    | Dealloc       (* x ↦̸   *)

  type t = {
    dummies : (Ide.t, Dummy.t, Ide.comparator_witness) Map.t;
    heap : (Dummy.t, heapval, Dummy.comparator_witness) Map.t;
    path_cond : Path_cond.t;
  }
\end{minted}

The motivation for keeping equalities on program variables (\ml{Ide.t}) separate from the rest is to be always able to apply the frame rule without extra processing. Propositions can be framed out only if they don't include program variables, so the only piece of the normal form that cannot be framed out is the \ml{dummies} map. All rules take either a generic proposition or a proposition that includes \(\mathrm{emp}_{\mathbb X_{p}}\), that can always match the formula represented by \ml{dummies}, which consequently never needs to be framed out.

The heap is represented by a map to easily identify duplicate chunks, that imply falsehood.

The path condition cannot contain disjunction, as the executor state represents a single branch in the symbolic execution. Whenever a disjunction would be produced, the executor is called on the two branches with two separate states instead. Moreover, it doesn't need existential quantifiers as they are removed by the normalization procedure.

\subsection{Normalization}

We produce a list of executor states from the input precondition as follows.
First, we rewrite the precondition to an intermediate form with the shape
\[\exists X.\;\bigvee_{i}\bigast_{j}\bigwedge_{k} A_{ijk},\]
with \(A\) an atomic proposition, by distributivity rules and pushing out of existential quantifiers (\texttt{norm\_prop.ml}). Then we separate the disjunct; we will produce a distinct state for each of them. We replace all program variables with fresh dummy variables, and remember the association in the \ml{dummies} map. Finally, we extract the chunks into the \ml{heap} map and put the rest into the path condition, turning \(\ast\) into \(\wedge\) as they are equivalent in the absence of chunks.

If we find two chunks for the same location in the same separating conjunct (\ie connected by \(\wedge\)), we keep only one in the \ml{heap} map and add an equality between the pointed-to values to the path condition. If we find them in the same disjunct (connected by \(\ast\)) we add false to the path condition.

\subsection{Executor status}

Executor states are wrapped in a monad that tracks the current status of the executor: produced a value, encountered an error, unable to apply any rule.

\begin{minted}{ocaml}
  type 'a status =
    | Ok of 'a (* typically 'a = Executor_state.t *)
    | Err of Executor_state.t
    | Stuck of Executor_state.t
\end{minted}

The executor is parameterized over the bind operator of the status monad, to generalize over the different interpretations of errors between SL+ and ISL+.

\begin{minted}{ocaml}
  (* SL+ *)
  let bind x f =
    match x with Ok s -> f s | Err s -> [ Stuck s ] | Stuck _ -> [ x ]

  (* ISL+ *)
  let bind x f =
    match x with
    | Ok s -> f s
    | Err s ->
        List.map (f s) ~f:(function Ok z -> Err z | (Err _ | Stuck _) as z -> z)
    | Stuck _ -> [ x ]
\end{minted}

When composing two computations \(f\) and \(g\), if the \(f\) an \ml{Ok} result then \(g\) is always executed; if \(f\) gets stuck the state is returned immediately, without executing \(g\); errors are turned into stuck states in SL+, while in ISL+ execution continues but \ml{Ok} results of \(g\) are turned into errors.

\subsection{Executor}

The executor is parameterized with a configuration structure, which includes the bind operator and functions implementing the rules that differ between SL+ and ISL+. It takes as input an executor state and a program, and returns a list of statuses, the possible outcomes (postconditions) of executing the program.

At the end of the execution of the whole program, we join the postconditions with disjunctions (according to the Disj and Choice rules) in SL+, while we keep them as different possible outcomes in ISL+.

\begin{minted}{ocaml}
  let rec exec cfg s p : Executor_state.t status list =
    let ( let* ) (ss : Executor_state.t status list) f =
      List.concat_map ss ~f:(fun s -> cfg.bind s f)
    in
    let open Prog in
    if Path_cond.is_false s.path_cond then []
    else
      let* s =
        match p with
        | Cmd c -> exec_cmd ~alloc_rule:cfg.alloc_rule s c
        | Seq (p1, p2) ->
            let* s = exec cfg s p1 in
            cfg.on_step s;
            exec cfg s p2
        | Choice (p1, p2) ->
            cfg.choice_rule s p1 p2
            |> List.concat_map ~f:(fun (s, p) -> exec cfg s p)
        | Iter p -> cfg.iter_rule (exec cfg) ( let* ) s p
      in
      match Executor_state.simpl s with Some s -> [ Ok s ] | None -> []
\end{minted}

We will briefly go over the implementation of all the rules.

\subsubsection{Commands}

The \ml{exec_cmd} function handles the following cases:

\minisec{Skip}

Successfully returns the current state as is.

\begin{minted}{ocaml}
  | Skip -> [ Ok s ]
\end{minted}

\minisec{Assert}

Corresponds to the \texttt{?} operator in the syntax.

Adds the boolean expression to the path condition. If the expression contains disjunctions multiple states are returned, one for each choice.

\begin{minted}{ocaml}
  | Assert e ->
      List.map (Executor_state.add_bexp_to_path_cond s e) ~f:(fun s -> Ok s)
\end{minted}

\minisec{Assign}

Assignment of an arithmetic expression \texttt{e} to a program variable \texttt{x} is performed as follows:
\begin{enumerate}
\item Create a fresh dummy variable \texttt{x'}.
\item Replace all program variables in \texttt{e} with dummy variables, obtaining \texttt{e'}. A variable \texttt{y} is replaced with \texttt{y'} if \texttt{y = y'} is in the executor state (\ie \texttt{y} maps to \texttt{y'} in \ml{s.dummies}), or with a fresh dummy variable (which is then added to \ml{dummies}) otherwise.
\item \texttt{x = x'} is added to \texttt{dummies} (possibly replacing a previous association of \texttt{x} to a dummy variable) and \texttt{x' = e'} to the path condition.
\end{enumerate}

So for each change to a program variable we introduce a new dummy variable that tracks that reflects that change. This differs from the original rules of the logic in that there the dummy variables are created on demand when needed. We instead chose an eager approach to facilitate the automated application of the frame rule.

\begin{minted}{ocaml}
  let assign s x e =
    let x' = Dummy.fresh_of_ide x in
    let dummies, e' = Executor_state.dummify_aexp s.dummies e in
    let e' = Aexp.simpl e' in
    Executor_state.add_bexp_to_path_cond
      { s with dummies = Map.set dummies ~key:x ~data:x' }
      (Cmp (Eq, Var x', e'))
    |> List.hd_exn
\end{minted}

\minisec{Load}

Corresponds to the \texttt{x ← [y]} syntax.

Looks up the dummy variable \texttt{y'} associated to \texttt{y}, then looks for \texttt{y' = 0} in the path condition, returning an error if it finds it. Otherwise, it finds a chunk for \texttt{y'} in the heap and assigns it to \texttt{x} as discussed above. \ml{heap_val} returns an error if \texttt{y'} has been deallocated, and \texttt{Stuck} if it was never allocated or is undefined (allocated but never assigned).

Note that in SL+ \ml{Err} is turned into \ml{Stuck} by the status monad, so we can reuse the same implementation for both logics even if ISL+ continues execution after reading from a null or deallocated location (in an error state) and SL+ doesn't.

\begin{minted}{ocaml}
  | AssignFromRef (x, y) ->
      let* y' = dummy_of y in
      if Path_cond.is_null s.path_cond y' then [ Err s ]
      else
        let* e = heap_val y' in
        [ Ok (assign s x e) ]
\end{minted}

\minisec{Store}

Stores (\texttt{[x] ← y}) work similarly, returning an error if \texttt{x}'s dummy variable \texttt{x'} is null or deallocated, and getting stuck if it was never allocated.

\texttt{store s x' v} adds a \texttt{x' ↦ v} chunk to the heap.

\begin{minted}{ocaml}
  | AssignToRef (x, y) ->
      let* x' = dummy_of x in
      if Path_cond.is_null s.path_cond x' then [ Err s ]
      else
        let v =
          match Map.find s.dummies y with
          | Some y' -> Aexp.Var y'
          | None -> Aexp.Num 0
        in
        let* _ = heap_has x' in
        [ Ok (store s x' (Val v)) ]
\end{minted}

\minisec{Allocation}

In SL+, \texttt{x ← alloc()} creates a new dummy variable \texttt{x'}, sets it as the current dummy variable for \texttt{x}, and adds a \texttt{x ↦ \_} chunk to the heap.

\begin{minted}{ocaml}
  let alloc_rule s x =
    let x' = Dummy.fresh_of_ide x in
    Ok
      Executor_state.
        {
          s with
          heap = Map.set s.heap ~key:x' ~data:Undefined;
          dummies = Map.set s.dummies ~key:x ~data:x';
        }
\end{minted}

In ISL+, we can additionally reuse previously deallocated locations. Interactively we ask the user whether to do it (and which to reuse) or not). Non-interactively we always reuse the first deallocated location we find. Sample implementation without the interactive choice:

\begin{minted}{ocaml}
  let alloc_rule s x =
    let open Executor_state in
    let x' =
      Map.to_alist s.heap
      |> List.find_map ~f:(function x', Dealloc -> Some x' | _ -> None)
      |> Option.value_or_thunk ~default:(fun () -> Dummy.fresh_of_ide x)
    in
    Ok
      {
        s with
        heap = Map.set s.heap ~key:x' ~data:Undefined;
        dummies = Map.set s.dummies ~key:x ~data:x';
      }
\end{minted}

\minisec{Free}

Similar to store, but replaces a \texttt{x' ↦ \_} or \texttt{x' ↦ v} chunk with \texttt{x' ↦̸}.

\begin{minted}{ocaml}
  | Free x ->
      let* x' = dummy_of x in
      if Path_cond.is_null s.path_cond x' then [ Err s ]
      else
        let* _ = heap_has x' in
        [ Ok (store s x' Dealloc) ]
\end{minted}

\minisec{Error}

Unsurprisingly:

\begin{minted}{ocaml}
  | Error -> [ Err s ]
\end{minted}

\subsubsection{Sequence}

This is simply a matter of executing the two programs in sequence. The bind operator takes care of errors, stuck executions, and branching (the second \ml{exec} call is applied to \emph{all} postconditions generated by the first).

\subsubsection{Choice}

This rule differs between SL+ and ISL+. In the former we execute both branches, in the latter we may select either both or a single one.

The SL+ implementation:
\begin{minted}{ocaml}
  let choice_rule s p1 p2 = [ (s, p1); (s, p2) ]
\end{minted}

In ISL+ we let the user choose the branch(es) interactively, or pick one at random.

\subsubsection{Iteration}

Iteration again differs between the two logics.

In ISL+, we can simply choose a number of iterations to perform (unrolling):
\begin{minted}{ocaml}
  let iter_rule exec ( let* ) s p =
    let rec unroll s n =
      if n = 0 then [ Ok s ]
      else
        let* s = exec s p in
        unroll s (n - 1)
    in
    unroll s 7
\end{minted}

In SL+, we use AI\footnote{Abstract Interpretation} to identify a loop invariant:
\begin{minted}{ocaml}
  let iter_rule exec ( let* ) s p =
    let* s' = exec s p in
    let s'' = Executor_state.abstract_join s s' in
    let* s''' = exec s'' p in
    [ Ok (Executor_state.abstract_join ~ensure_equal:true s'' s''') ]
\end{minted}
we execute the loop body once, find a proposition that is valid both before and after the iteration (candidate invariant) via the \ml{abstract_join} function, then execute again the body using that proposition as the precondition. If the candidate is equivalent to the postcondition after the latter iteration we use it as the invariant. If it isn't, a trivial postcondition (true) is returned.

\ml{abstract_join} performs a simple abstract interpretation of the path condition over the domain of integer bounds. For example, it interprets \(x + 1\) as \(\geq 0\) if \(x = 0\). This is enough to conclude:
\begin{minted}{text}
  { 0 <= x ∗ 0 <= y }  (y ← y + x)⋆  { y >= 0 }
\end{minted}

We don't support invariants involving changes to the heap; if the heap is modified in the loop, we use true as the invariant.

Since we create a new dummy variable for each change to a program variable, loop bodies that modify a variable never have their precondition equal to the postcondition. For example:
\begin{minted}{text}
  { x = 0 }  x ← 0  { x = 0 }
\end{minted}
is actually:
\begin{minted}{text}
  { x = x' ∧ x' = 0 }  x ← 0  { x = x'' ∧ x' = 0 ∧ x'' = 0 }
\end{minted}
so when checking for equality we keep only the last version of each dummy variable and ignore the superscript. Here we would be comparing \texttt{\{ x = x' ∧ x' = 0 \}} with \texttt{\{ x = x'' ∧ x'' = 0 \}} and considering \texttt{x'} equal to \texttt{x''}.

\section{Simplification}

At various points a number of simplification procedures are applied to the formulas generated by the executor. The key ones are those for executor states, path conditions and arithmetic expressions.

Arithmetic simplification (\texttt{aexp.ml}) applies a set of rewriting rules that push parentheses and constants to the right, replacing subexpressions with their computed result whenever possible.

Path conditions are conjunctions of boolean constants and comparisons. Simplification eliminates the constants and applies arithmetic simplification to the operands of the comparisons. It then tries to reason about bounds, \eg eliminating \texttt{x < 1} from \texttt{x < 0 ∧ x < 1}. % FIXME doesn't work

To simplify an executor state we first invoke the path condition simplification procedure, then try to extract and apply substitutions from the path condition. For example, if we have \texttt{x' = 0} in the path condition and \texttt{y' ↦ x'} in the heap, we replace the chunk with \texttt{y' ↦ 0}; from \texttt{x' ↦ \_ ∗ y' ↦ \_ ∧ x' = y'} we deduce false.

We also have a few more basic procedures for other types, such as the AST produced from reading the user's precondition and from the final list of executor states.

\section{Front-end}
Users can run the project using the command \texttt{dune exec lis-project path\_to\_file},
providing as argument the path to a file containing the content to execute.
A valid input file must specify a precondition and a program, adhering to the following standard structure:

\begin{minted}{text}
{ precondition }
program
# Comments can be written by starting them with an '#'
\end{minted}

Files can have as extension either \texttt{.sl} or \texttt{.isl}, 
indicating whether they should be executed using 
\textit{Separation Logic+} or \textit{Incorrectness Separation Logic+}.


\subsection{Staring the execution}
The application's entry point is defined in \texttt{main.ml}.
Upon execution the application attemps to load the file and then passes it to the lexer, defined in \texttt{lexer.mll}. 
The file is scanned from beginning to end, stripping away any syntatic sugar and identifying valid tokes.
The more complex tokens are handled as follows:

\begin{enumerate}
  \item Any sequence of characters starting with a \# is considered a comment, thus ignored by the lexer.
  
  \item \texttt{INT:} a sequence of digits is recognized as an integer. 
  The string is then converted into an OCaml's integer value and wrapped in the \texttt{INT} token.
      

  \item \texttt{ID:} an identifier is recognizes as a sequence of alphabetic characters (both uppercase and lowercase) which does not match any other token. 
        The matching text is stored as part of the \texttt{ID} token.
  
  \item \texttt{DUMMY\_ID}: a dummy identifier is similar to an identifier, with the exception that
        its sequence must end with one or more '\textbackslash{}'.
        The portion before the backslashes is treated as the name, while the number of backslashes corresponds to the number of apices of the variable.
        Both values are wrapped into the \texttt{DUMMY\_ID} token: the name as a string and the number of apices as an integer.
\end{enumerate}

The list of remaning valid tokens is the following:
\begin{multicols}{3} % Adjust number of columns as needed
\begin{itemize}
\item \texttt{LPAREN} : \texttt{(}
\item \texttt{RPAREN} : \texttt{)}
\item \texttt{LBRACE} : \texttt{\{}
\item \texttt{RBRACE} : \texttt{\}}
\item \texttt{PLUS} : \texttt{+}
\item \texttt{MINUS} : \texttt{-}
\item \texttt{MULT} : \texttt{**} | \texttt{×}
\item \texttt{DIV} : \texttt{/}
\item \texttt{MOD} : \texttt{\%}
\item \texttt{BOOL(true)} : \texttt{true} | \texttt{⊤}
\item \texttt{BOOL(false)} : \texttt{} | \texttt{⊥}
\item \texttt{OR} : \texttt{||} | \texttt{∨}
\item \texttt{AND} : \texttt{\&\&} | \texttt{∧}
\item \texttt{NOT} : \texttt{!} | \texttt{¬}
\item \texttt{LT} : \texttt{<}
\item \texttt{LE} : \texttt{<=} | \texttt{≤}
\item \texttt{GT} : \texttt{>}
\item \texttt{GE} : \texttt{>=} | \texttt{≥}
\item \texttt{EQ} : \texttt{=}
\item \texttt{NEQ} : \texttt{!=} | \texttt{<>} | \texttt{≠}
\item \texttt{EMP} : \texttt{emp}
\item \texttt{REF} : \texttt{->} | \texttt{↦}
\item \texttt{NREF} : \texttt{!->} | \texttt{!↦} | \texttt{↦̸}
\item \texttt{SOMETHING} : \texttt{\_}
\item \texttt{EXIST} : \texttt{exists} | $\exists$
\item \texttt{SEP} : \texttt{*} | \texttt{∗}
\item \texttt{DOT} : \texttt{.}
\item \texttt{SEMICOLON} : \texttt{;}
\item \texttt{SKIP} : \texttt{skip}
\item \texttt{QUESTION} : \texttt{?}
\item \texttt{LBRACK} : \texttt{[}
\item \texttt{RBRACK} : \texttt{]}
\item \texttt{ASSIGN} : \texttt{:=} | \texttt{←}
\item \texttt{ALLOC} : \texttt{alloc}
\item \texttt{FREE} : \texttt{free}
\item \texttt{ERROR} : \texttt{error}
\item \texttt{STAR} : \texttt{star} | \texttt{⋆}
\end{itemize}
\end{multicols}

The lexer then returns the ordered list of generated tokens, which is then passed to the parser, defined in \texttt{parser.mly}.
The parser's purpose is to check whether this sequence of tokens forms a syntactically correct program and if so, it trasforms it into an Abstract Syntax Tree(AST).
The principal parsed AST types are:

\begin{enumerate}
  \item \texttt{Aexp.t}: an arithmetic expression. It can be either a binary operator between two valid arithmetic expressions (addition, subtraction, multiplication, division or modulo), the negation of an arithmetic expression, or the equality between an arithmetic expression and a variable (an \texttt{ID} token).

  \item \texttt{Bexp.t}: a boolean expression. It can be either a boolean constant (true or false), a comparison between two valid arithmetic expressions, the conjunction or disjunction between two boolean expression, or the negation of a boolean expression.

  \item \texttt{Dummy.t}: an identifier. A \texttt{ID} token is treated as a dummy variable with number of apices equal to 0; a \texttt{DUMMY\_ID} token creates a dummy variable with the associated number of apices.
  
  \item \texttt{Atom.t}: an atomic proposition. It can be either a boolean expression, a points-to-anything assertion of the form $x \rightarrow \_$, a points-to assertion with an arithmetic expression in the form $x \rightarrow a$, a dangling pointer assertion in the form $x \nrightarrow$, or the empty heap.
  
  \item \texttt{Prop.t}: a proposition. It can be either an atomic one, the conjunction or disjunction between two proposition, or an existentially quantified proposition (i.e. $\exists x. prop$).
  
  \item \texttt{Cmd.t}: a command. It could be $skip$, a boolean assertion, an assignement to an arithmetic expression, a store, a load, an allocation, a deallocation, or \texttt{error}.
  
  \item \texttt{Prog.t}: a program. It could be a command, the non-deterministic choice between two commands, the Kleene star, or the sequential composition of two or more programs. Note that a program in our syntax can either end with a semicolon or not.
\end{enumerate}
Finally, a well-formed input file has the shape \verb|{ P } C|, where \texttt{P} is a proposition (\texttt{Prop.t}) and \texttt{C} is a program (\texttt{Prog.t}).


The \texttt{main} function then applies a normalization step over the produced AST's representation of the precondition, followed by a simplification step.
Finally, the executor is invoked with the simplified precondition and the corresponding program.

During execution, the application continuously displays the current command being executed along with the executor’s state.

\subsection{ISL+ user's interaction}
When executing an \textit{Incorrectness Separation Logic+} triple, the front-end offers some degree of interaction depending on the rule being applied:

\begin{itemize}
  \item \texttt{Allocation:} three allocation strategies are available:
    \begin{itemize}
      \item Reuse the first available deallocated location, if any exists.
      \item Manually select which available deallocated location to reuse, if any exists
      \item Allocate a new memory location, ignoring any available deallocated ones.
    \end{itemize}
  \item \texttt{Choice:} the user can choose which branch to execute or execute both branches.
  \item \texttt{Iteration:} the user specifies the number $n$ of iterations to perform, and then decides whether to: 
    \begin{itemize}
      \item Collect all intermediate states produced during the rule's execution or only consider those after the $n$ iterations have been done.
      \item Only consider the states resulting after the $n$ iterations.
    \end{itemize}
\end{itemize}

\section{Examples}

The following section will list some examples, starting from the input files content and showing the corresponding output.

The examples will highlight the verifier's key capabilities, progressing from simple to more complex scenarios.

Some of the examples include as last commented line a possible valid expected post condition.  

\subsection{SL+ Examples}

\begin{enumerate}

\item \textbf{Input file}: 
\begin{minted}{text}
{ y ↦ v }
x := [y]
# { x=v ∧ y ↦ v }
\end{minted}

\textbf{Output}: 
\begin{minted}{text}
Simplified precondition:
y ↦ v
=========================
Execution from state:
y¹ ↦ v¹ ∧ v = v¹ ∧ y = y¹ ∧ ⊤
-------------------------
v = v¹ ∧ x = v¹ ∧ y = y¹ ∧ y¹ ↦ v¹ ∧ x¹ = v¹
\end{minted}

\item 
\textbf{Input file}: 
\begin{minted}{text}
{ x ↦ _ }
[x] := y; 
# {x ↦ y }
\end{minted}

\textbf{Output}: 
\begin{minted}{text}
Simplified precondition:
x ↦ _
=========================
Execution from state:
x¹ ↦ _∧ x = x¹∧ ⊤
-------------------------
x = x¹ ∧ x¹ ↦ 0
\end{minted}

\item 
\textbf{Input file}: 
\begin{minted}{text}
{ emp }
x := alloc()
# { x ↦ _ } 
\end{minted}

\textbf{Output}: 
\begin{minted}{text}
Simplified precondition:
⊤
=========================
Execution from state:
⊤
-------------------------
x = x¹ ∧ x¹ ↦ _
\end{minted}

\item 
\textbf{Input file}: 
\begin{minted}{text}
{ x ↦ _ }
free(x); 
# {emp}
\end{minted}

\textbf{Output}: 
\begin{minted}{text}
Simplified precondition:
x ↦ _
=========================
Execution from state:
x¹ ↦ _ ∧ x = x¹ ∧ ⊤
-------------------------
x = x¹ ∧ x¹ ↦̸
\end{minted}

\item 
\textbf{Input file}: 
\begin{minted}{text}
{false}
[x] := y   
#{false}
\end{minted}

\textbf{Output}: 
\begin{minted}{text}
Simplified precondition:
⊥
⊥ (all branches pruned)
\end{minted}

\item 
\textbf{Input file}: 
\begin{minted}{text}
{ (-(x × 5) + (8 / 4 - x) × -x / 7 + -x + -x × -1) = 0 }
skip
\end{minted}

\textbf{Output}: 
\begin{minted}{text}
Simplified precondition:
(-x + 2) × x / -7 - x × 5 = 0
=========================
Execution from state:
x = x¹ ∧ (-x¹ + 2) × x¹ / -7 - x¹ × 5 = 0
-------------------------
x = x¹ ∧ (-x¹ + 2) × x¹ / -7 - x¹ × 5 = 0
\end{minted}

\item 
\textbf{Input file}: 
\begin{minted}{text}
{ 0 <= x ∗ 0 <= y }
(y ← y + x)⋆
# y >= 0
\end{minted}

\textbf{Output}: 
\begin{minted}{text}
Simplified precondition:
0 ≤ y ∗ 0 ≤ x
=========================
Execution from state:
x = x¹ ∧ y = y¹ ∧ 0 ≤ y¹ ∧ 0 ≤ x¹
-------------------------
x = x¹ ∧ y = y¹ ∧ -y¹ ≤ 0 ∧ -x¹ ≤ 0
\end{minted}

\item \textbf{Input file}: 
\begin{minted}{text}
{ ⊤ }
(x = 1?; y ← x) + (x = 2?; y ← x)
\end{minted}

\textbf{Output}: 
\begin{minted}{text}
Simplified precondition:
⊤
=========================
Execution from state:
⊤
-------------------------
x = x¹ ∧ x¹ = 1
-------------------------
x = x² ∧ x² = 2
-------------------------
x = x¹ ∧ y = x¹ ∧ x¹ = 1 ∧ y¹ = 1
∨ x = x² ∧ y = x² ∧ x² = 2 ∧ y² = 2
\end{minted}

\item 
\textbf{Input file}: 
\begin{minted}{text}
{ ⊤ }

x := 0;
y := 1;
(y := y + 1)⋆;
(x := x - y)⋆;
((x > 0)?; z := 1) + ((x < 0)?; z := 2);
\end{minted}

\textbf{Output}: 
\begin{minted}{text}
Simplified precondition:
⊤
=========================
Execution from state:
⊤
-------------------------
x = x¹ ∧ x¹ = 0
-------------------------
x = x¹ ∧ y = y¹ ∧ x¹ = 0 ∧ y¹ = 1
-------------------------
x = x¹ ∧ y = y¹ ∧ -y¹ ≤ -1 ∧ x¹ = 0
-------------------------
x = x¹ ∧ y = y¹ ∧ -y¹ ≤ -1 ∧ x¹ ≤ 0
-------------------------
x = x¹ ∧ y = y¹ ∧ ⊥
-------------------------
<= 0 < 0 < 0 <= 0 x = x¹ ∧ y = y¹ ∧ -y¹ ≤ -1 ∧ x¹ < 0
-------------------------
x = x¹ ∧ y = y¹ ∧ z = z¹ ∧ -y¹ ≤ -1 ∧ x¹ < 0 ∧ z¹ = 2
\end{minted}

\end{enumerate}

\subsection{ISL+ Examples}

\begin{enumerate}
\item 
\textbf{Input file}: 
\begin{minted}{text}
{ x = nil }
[x] := y
# { er: x = nil }
\end{minted}

\textbf{Output}: 
\begin{minted}{text}
Simplified precondition:
x = nil
=========================
Execution from state:
nil = nil¹ ∧ x = x¹ ∧ x¹ = nil¹
-------------------------
[stuck]
nil = nil¹ ∧ x = x¹ ∧ x¹ = nil¹
-------------------------
\end{minted}

\item 
\textbf{Input file}: 
\begin{minted}{text}
{ x ↦̸ }
free(x)
# {er: x ↦̸ }
\end{minted}

\textbf{Output}: 
\begin{minted}{text}
Simplified precondition:
x ↦̸
=========================
Execution from state:
x¹ ↦̸ ∧ x = x¹ ∧ ⊤
-------------------------
[error]
x¹ ↦̸ ∧ x = x¹ ∧ 
-------------------------
\end{minted}

\item 
\textbf{Input file}: 
\begin{minted}{text}
{ x ↦ v }
free(x)
# {ok: x ↦̸ }
\end{minted}

\textbf{Output}: 
\begin{minted}{text}
Simplified precondition:
x ↦ v
=========================
Execution from state:
x¹ ↦ v¹ ∧ v = v¹ ∧ x = x¹ ∧ ⊤
-------------------------
v = v¹ ∧ x = x¹ ∧ x¹ ↦̸ ∧ ⊤
\end{minted}

\item 
\textbf{Input file}: 
\begin{minted}{text}
{ x = x' }
x := alloc()
# { ok: x ↦ _ }
\end{minted}

\textbf{Output}: 
\begin{minted}{text}
Simplified precondition:
x = x¹
=========================
Execution from state:
x = x² ∧ x² = x¹
-------------------------
x = x³ ∧ x³ ↦ _ ∧ ⊤ ∧ x² = x¹
\end{minted}

\item 
\textbf{Input file}: 
\begin{minted}{text}
{ y ↦̸ }
x := alloc()
# { ok: x ↦ v ∧ x = y }
\end{minted}

\textbf{Output}: 
\begin{minted}{text}
Simplified precondition:
y ↦̸
=========================
Execution from state:
y¹ ↦̸ ∧ y = y¹ ∧ ⊤
-------------------------
x = y¹ ∧ y = y¹ ∧ y¹ ↦ _ ∧ ⊤
\end{minted}

\item 
\textbf{Input file}: 
\begin{minted}{text}
{ x = nil }
free(x)
# {er: x = nil}
\end{minted}

\item 
\textbf{Input file}: 
\begin{minted}{text}
{ ⊤ }
x ← 0;
(x ← x + 1)⋆
\end{minted}

\textbf{Output}: 
\begin{minted}{text}
Simplified precondition:
⊤
=========================
Execution from state:
⊤
-------------------------
x = x¹ ∧ x¹ = 0
-------------------------
x = x⁸ ∧ emp ∧ ⊤ ∧ x¹ = 0 ∧ x² = 1 ∧ x³ = 2 ∧ x⁴ = 3 
∧ x⁵ = 4 ∧ x⁶ = 5 ∧ x⁷ = 6 ∧ x⁸ = 7
\end{minted}

\textbf{Output}: 
\begin{minted}{text}
Simplified precondition:
x = nil
=========================
Execution from state:
nil = nil¹ ∧ x = x¹ ∧ x¹ = nil¹
-------------------------
[stuck]
nil = nil¹ ∧ x = x¹ ∧ x¹ = nil¹
-------------------------
\end{minted}

\item 
\textbf{Input file}: 
\begin{minted}{text}
{ (-(x × 5) + (8 / 4 - x) × -x / 7 + -x + -x × -1) = 0 }
skip
\end{minted}

\textbf{Output}: 
\begin{minted}{text}
Simplified precondition:
(-x + 2) × x / -7 - x × 5 = 0
=========================
Execution from state:
x = x¹ ∧ (-x¹ + 2) × x¹ / -7 - x¹ × 5 = 0
-------------------------
x = x¹ ∧ emp ∧ ⊤ ∧ (-x¹ + 2) × x¹ / -7 - x¹ × 5 = 0
\end{minted}

\end{enumerate}

\end{document}
