\documentclass[parskip=half]{scrartcl}

\title{Computing SL+ and ISL+ postconditions via symbolic execution}
\subtitle{LIS project}
\date{2025-06-xx}
\author{ % random order
  Massimiliano Baglioni      \and
  Salvatore Salerno          \and
  Anna Francesca Montagnoli  \and
  Sofia Pisani               \and
  Lorenzo Pace               \and
  Jhonatan Azevedo Gonçalves \and
  Alessio Duè                \and
  Pamela Di Clemente         \and
  Emanuele Buonaccorsi}

\input{preamble.tex}

\begin{document}

\maketitle

\begin{abstract}
  We present a tool to compute SL+ and ISL+ postconditions.
\end{abstract}

\section{Dummy stuff}

brief description of the logic and its rules

\section{Symbolic execution}

Given a precondition and a program, we produce a postcondition by means of symbolic execution. The program is executed step by step, using the postcondition of a command as the precondition of the next.

\subsection{Executor state}

During symbolic execution, the logical proposition that is currently known to hold (\ie the postcondition of the previous command or initial precondition) is kept in a normal form with the following shape:
\begin{align*}
  &x = x' \wedge y = y' \wedge \dots \\
  &\wedge (x' \mapsto a_1 \ast x'' \mapsto a_2 \ast \dots \ast y' \mapsto b_1 \ast y'' \mapsto b_2 \ast \dots) \\
  &\wedge p
\end{align*}
\ie a single equality between each program variable and a dummy variable, the heap with possibly a chunk for each dummy variable (but not for program variables), and a path condition \(p\). The path condition is a conjunction of comparisons and boolean constants, and cannot contain program variables.

In OCaml, this is implemented as (\texttt{executor\_state.ml}):
\begin{minted}{ocaml}
  type heapval =
    | Val of Aexp.t (* x ↦ e *)
    | Undefined     (* x ↦ _ *)
    | Dealloc       (* x ↦̸   *)

  type t = {
    dummies : (Ide.t, Dummy.t, Ide.comparator_witness) Map.t;
    heap : (Dummy.t, heapval, Dummy.comparator_witness) Map.t;
    path_cond : Path_cond.t;
  }
\end{minted}

The motivation for keeping equalities on program variables (\ml{Ide.t}) separate from the rest is to be always able to apply the frame rule without extra processing. Propositions can be framed out only if they don't include program variables, so the only piece of the normal form that cannot be framed out is the \ml{dummies} map. All rules take either a generic proposition or a proposition that includes \(\mathrm{emp}_{\mathbb X_{p}}\), that can always match the formula represented by \ml{dummies}, which consequently never needs to be framed out.

The heap is represented by a map to easily identify duplicate chunks, that imply falsehood.

The path condition cannot contain disjunction, as the executor state represents a single branch in the symbolic execution. Whenever a disjunction would be produced, the executor is called on the two branches with two separate states instead. Moreover, it doesn't need existential quantifiers as they are removed by the normalization procedure.

\subsection{Normalization}

We produce a list of executor states from the input precondition as follows.
First, we rewrite the precondition to an intermediate form with the shape
\[\exists X.\;\bigvee_{i}\bigast_{j}\bigwedge_{k} A_{ijk},\]
with \(A\) an atomic proposition, by distributivity rules and pushing out of existential quantifiers (\texttt{norm\_prop.ml}). Then we separate the disjunct; we will produce a distinct state for each of them. We replace all program variables with fresh dummy variables, and remember the association in the \ml{dummies} map. Finally, we extract the chunks into the \ml{heap} map and put the rest into the path condition, turning \(\ast\) into \(\wedge\) as they are equivalent in the absence of chunks.

If we find two chunks for the same location in the same separating conjunct (\ie connected by \(\wedge\)), we keep only one in the \ml{heap} map and add an equality between the pointed-to values to the path condition. If we find them in the same disjunct (connected by \(\ast\)) we add false to the path condition.

\subsection{Executor status}

Executor states are wrapped in a monad that tracks the current status of the executor: produced a value, encountered an error, unable to apply any rule.

\begin{minted}{ocaml}
  type 'a status =
    | Ok of 'a (* typically 'a = Executor_state.t *)
    | Err of Executor_state.t
    | Stuck of Executor_state.t
\end{minted}

The executor is parameterized over the bind operator of the status monad, to generalize over the different interpretations of errors between SL+ and ISL+.

\begin{minted}{ocaml}
  (* SL+ *)
  let bind x f =
    match x with Ok s -> f s | Err s -> [ Stuck s ] | Stuck _ -> [ x ]

  (* ISL+ *)
  let bind x f =
    match x with
    | Ok s -> f s
    | Err s ->
        List.map (f s) ~f:(function Ok z -> Err z | (Err _ | Stuck _) as z -> z)
    | Stuck _ -> [ x ]
\end{minted}

When composing two computations \(f\) and \(g\), if the \(f\) an \ml{Ok} result then \(g\) is always executed; if \(f\) gets stuck the state is returned immediately, without executing \(g\); errors are turned into stuck states in SL+, while in ISL+ execution continues but \ml{Ok} results of \(g\) are turned into errors.

\subsection{Executor}

The executor is parameterized with a configuration structure, which includes the bind operator and functions implementing the rules that differ between SL+ and ISL+. It takes as input an executor state and a program, and returns a list of statuses, the possible outcomes (postconditions) of executing the program.

At the end of the execution of the whole program, we join the postconditions with disjunctions (according to the Disj and Choice rules) in SL+, while we keep them as different possible outcomes in ISL+.

\begin{minted}{ocaml}
  let rec exec cfg s p : Executor_state.t status list =
    let ( let* ) (ss : Executor_state.t status list) f =
      List.concat_map ss ~f:(fun s -> cfg.bind s f)
    in
    let open Prog in
    if Path_cond.is_false s.path_cond then []
    else
      let* s =
        match p with
        | Cmd c -> exec_cmd ~alloc_rule:cfg.alloc_rule s c
        | Seq (p1, p2) ->
            let* s = exec cfg s p1 in
            cfg.on_step s;
            exec cfg s p2
        | Choice (p1, p2) ->
            cfg.choice_rule s p1 p2
            |> List.concat_map ~f:(fun (s, p) -> exec cfg s p)
        | Iter p -> cfg.iter_rule (exec cfg) ( let* ) s p
      in
      match Executor_state.simpl s with Some s -> [ Ok s ] | None -> []
\end{minted}

We will briefly go over the implementation of all the rules.

\subsubsection{Commands}

The \ml{exec_cmd} function handles the following cases:

\minisec{Skip}

Successfully returns the current state as is.

\begin{minted}{ocaml}
  | Skip -> [ Ok s ]
\end{minted}

\minisec{Assert}

Corresponds to the \texttt{?} operator in the syntax.

Adds the boolean expression to the path condition. If the expression contains disjunctions multiple states are returned, one for each choice.

\begin{minted}{ocaml}
  | Assert e ->
      List.map (Executor_state.add_bexp_to_path_cond s e) ~f:(fun s -> Ok s)
\end{minted}

\minisec{Assign}

Assignment of an arithmetic expression \texttt{e} to a program variable \texttt{x} is performed as follows:
\begin{enumerate}
\item Create a fresh dummy variable \texttt{x'}.
\item Replace all program variables in \texttt{e} with dummy variables, obtaining \texttt{e'}. A variable \texttt{y} is replaced with \texttt{y'} if \texttt{y = y'} is in the executor state (\ie \texttt{y} maps to \texttt{y'} in \ml{s.dummies}), or with a fresh dummy variable (which is then added to \ml{dummies}) otherwise.
\item \texttt{x = x'} is added to \texttt{dummies} (possibly replacing a previous association of \texttt{x} to a dummy variable) and \texttt{x' = e'} to the path condition.
\end{enumerate}

So for each change to a program variable we introduce a new dummy variable that tracks that reflects that change. This differs from the original rules of the logic in that there the dummy variables are created on demand when needed. We instead chose an eager approach to facilitate the automated application of the frame rule.

\begin{minted}{ocaml}
  let assign s x e =
    let x' = Dummy.fresh_of_ide x in
    let dummies, e' = Executor_state.dummify_aexp s.dummies e in
    let e' = Aexp.simpl e' in
    Executor_state.add_bexp_to_path_cond
      { s with dummies = Map.set dummies ~key:x ~data:x' }
      (Cmp (Eq, Var x', e'))
    |> List.hd_exn
\end{minted}

\minisec{Load}

Corresponds to the \texttt{x ← [y]} syntax.

Looks up the dummy variable \texttt{y'} associated to \texttt{y}, then looks for \texttt{y' = 0} in the path condition, returning an error if it finds it. Otherwise, it finds a chunk for \texttt{y'} in the heap and assigns it to \texttt{x} as discussed above. \ml{heap_val} returns an error if \texttt{y'} has been deallocated, and \texttt{Stuck} if it was never allocated or is undefined (allocated but never assigned).

Note that in SL+ \ml{Err} is turned into \ml{Stuck} by the status monad, so we can reuse the same implementation for both logics even if ISL+ continues execution after reading from a null or deallocated location (in an error state) and SL+ doesn't.

\begin{minted}{ocaml}
  | AssignFromRef (x, y) ->
      let* y' = dummy_of y in
      if Path_cond.is_null s.path_cond y' then [ Err s ]
      else
        let* e = heap_val y' in
        [ Ok (assign s x e) ]
\end{minted}

\minisec{Store}

Stores (\texttt{[x] ← y}) work similarly, returning an error if \texttt{x}'s dummy variable \texttt{x'} is null or deallocated, and getting stuck if it was never allocated.

\texttt{store s x' v} adds a \texttt{x' ↦ v} chunk to the heap.

\begin{minted}{ocaml}
  | AssignToRef (x, y) ->
      let* x' = dummy_of x in
      if Path_cond.is_null s.path_cond x' then [ Err s ]
      else
        let v =
          match Map.find s.dummies y with
          | Some y' -> Aexp.Var y'
          | None -> Aexp.Num 0
        in
        let* _ = heap_has x' in
        [ Ok (store s x' (Val v)) ]
\end{minted}

\minisec{Allocation}

In SL+, \texttt{x ← alloc()} creates a new dummy variable \texttt{x'}, sets it as the current dummy variable for \texttt{x}, and adds a \texttt{x ↦ \_} chunk to the heap.

\begin{minted}{ocaml}
  let alloc_rule s x =
    let x' = Dummy.fresh_of_ide x in
    Ok
      Executor_state.
        {
          s with
          heap = Map.set s.heap ~key:x' ~data:Undefined;
          dummies = Map.set s.dummies ~key:x ~data:x';
        }
\end{minted}

In ISL+, we can additionally reuse previously deallocated locations. As a proof of concept we always reuse the first deallocated location we find, but the rule could be easily adapted so that it explores multiple possibilities.

\begin{minted}{ocaml}
  let alloc_rule s x =
    let open Executor_state in
    let x' =
      Map.to_alist s.heap
      |> List.find_map ~f:(function x', Dealloc -> Some x' | _ -> None)
      |> Option.value_or_thunk ~default:(fun () -> Dummy.fresh_of_ide x)
    in
    Ok
      {
        s with
        heap = Map.set s.heap ~key:x' ~data:Undefined;
        dummies = Map.set s.dummies ~key:x ~data:x';
      }
\end{minted}

\minisec{Free}

Similar to store, but replaces a \texttt{x' ↦ \_} or \texttt{x' ↦ v} chunk with \texttt{x' ↦̸}.

\begin{minted}{ocaml}
  | Free x ->
      let* x' = dummy_of x in
      if Path_cond.is_null s.path_cond x' then [ Err s ]
      else
        let* _ = heap_has x' in
        [ Ok (store s x' Dealloc) ]
\end{minted}

\minisec{Error}

Unsurprisingly:

\begin{minted}{ocaml}
  | Error -> [ Err s ]
\end{minted}

\subsubsection{Sequence}

This is simply a matter of executing the two programs in sequence. The bind operator takes care of errors, stuck executions, and branching (the second \ml{exec} call is applied to \emph{all} postconditions generated by the first).

\subsubsection{Choice}

This rule differs between SL+ and ISL+. In the former we execute both branches, in the latter we may select either both or a single one.

\begin{minted}{ocaml}
  (* SL+ *)
  let choice_rule s p1 p2 = [ (s, p1); (s, p2) ]

  (* ISL+ TODO *)
  let choice_rule s p1 _p2 = [ (s, p1) ]
\end{minted}

\subsubsection{Iteration}

Iteration again differs between the two logics.

In ISL+, we can simply choose a number of iterations to perform (unrolling):
\begin{minted}{ocaml}
  let iter_rule exec ( let* ) s p =
    let rec unroll s n =
      if n = 0 then [ Ok s ]
      else
        let* s = exec s p in
        unroll s (n - 1)
    in
    unroll s 7
\end{minted}

In SL+, we use AI\footnote{Abstract Interpretation} to identify a loop invariant:
\begin{minted}{ocaml}
  let iter_rule exec ( let* ) s p =
    let* s' = exec s p in
    let s'' = Executor_state.abstract_join s s' in
    let* s''' = exec s'' p in
    [ Ok (Executor_state.abstract_join ~ensure_equal:true s'' s''') ]
\end{minted}
we execute the loop body once, find a proposition that is valid both before and after the iteration (candidate invariant) via the \ml{abstract_join} function, then execute again the body using that proposition as the precondition. If the candidate is equivalent to the postcondition after the latter iteration we use it as the invariant. If it isn't, a trivial postcondition (true) is returned.

\ml{abstract_join} performs a simple abstract interpretation of the path condition over the domain of integer bounds. For example, it interprets \(x + 1\) as \(\geq 0\) if \(x = 0\). This is enough to conclude:
\begin{minted}{text}
  { 0 <= x ∗ 0 <= y }  (y ← y + x)⋆  { y >= 0 }
\end{minted}

We don't support invariants involving changes to the heap; if the heap is modified in the loop, we use true as the invariant.

Since we create a new dummy variable for each change to a program variable, loop bodies that modify a variable never have their precondition equal to the postcondition. For example:
\begin{minted}{text}
  { x = 0 }  x ← 0  { x = 0 }
\end{minted}
is actually:
\begin{minted}{text}
  { x = x' ∧ x' = 0 }  x ← 0  { x = x'' ∧ x' = 0 ∧ x'' = 0 }
\end{minted}
so when checking for equality we keep only the last version of each dummy variable and ignore the superscript. Here we would be comparing \texttt{\{ x = x' ∧ x' = 0 \}} with \texttt{\{ x = x'' ∧ x'' = 0 \}} and considering \texttt{x'} equal to \texttt{x''}.

\section{Simplification}

At various points a number of simplification procedures are applied to the formulas generated by the executor. The key ones are those for executor states, path conditions and arithmetic expressions.

Arithmetic simplification (\texttt{aexp.ml}) applies a set of rewriting rules that push parentheses and constants to the right, replacing subexpressions with their computed result whenever possible.

Path conditions are conjunctions of boolean constants and comparisons. Simplification eliminates the constants and applies arithmetic simplification to the operands of the comparisons. It then tries to reason about bounds, \eg eliminating \texttt{x < 1} from \texttt{x < 0 ∧ x < 1}. % FIXME doesn't work

To simplify an executor state we first invoke the path condition simplification procedure, then try to extract and apply substitutions from the path condition. For example, if we have \texttt{x' = 0} in the path condition and \texttt{y' ↦ x'} in the heap, we replace the chunk with \texttt{y' ↦ 0}; from \texttt{x' ↦ \_ ∗ y' ↦ \_ ∧ x' = y'} we deduce false.

We also have a few more basic procedures for other types, such as the AST produced from reading the user's precondition and from the final list of executor states.

\section{Parser and front-end}

\section{Examples}

The following section will list some examples, starting from the input files content and showing the corresponding output.

The examples will highlight the verifier's key capabilities, progressing from simple to more complex scenarios.

Some of the examples include as last commented line a possible valid expected post condition.  

\subsection{SL+ Examples}

\begin{enumerate}

\item \textbf{Input file}: 
\begin{minted}{text}
{ y ↦ v }
x := [y]
# { x=v ∧ y ↦ v }
\end{minted}

\textbf{Output}: 
\begin{minted}{text}
Simplified precondition:
y ↦ v
=========================
Execution from state:
y¹ ↦ v¹ ∧ v = v¹ ∧ y = y¹ ∧ ⊤
-------------------------
v = v¹ ∧ x = v¹ ∧ y = y¹ ∧ y¹ ↦ v¹ ∧ x¹ = v¹
\end{minted}

\item 
\textbf{Input file}: 
\begin{minted}{text}
{ x ↦ _ }
[x] := y; 
# {x ↦ y }
\end{minted}

\textbf{Output}: 
\begin{minted}{text}
Simplified precondition:
x ↦ _
=========================
Execution from state:
x¹ ↦ _∧ x = x¹∧ ⊤
-------------------------
x = x¹ ∧ x¹ ↦ 0
\end{minted}

\item 
\textbf{Input file}: 
\begin{minted}{text}
{ emp }
x := alloc()
# { x ↦ _ } 
\end{minted}

\textbf{Output}: 
\begin{minted}{text}
Simplified precondition:
⊤
=========================
Execution from state:
⊤
-------------------------
x = x¹ ∧ x¹ ↦ _
\end{minted}

\item 
\textbf{Input file}: 
\begin{minted}{text}
{ x ↦ _ }
free(x); 
# {emp}
\end{minted}

\textbf{Output}: 
\begin{minted}{text}
Simplified precondition:
x ↦ _
=========================
Execution from state:
x¹ ↦ _ ∧ x = x¹ ∧ ⊤
-------------------------
x = x¹ ∧ x¹ ↦̸
\end{minted}

\item 
\textbf{Input file}: 
\begin{minted}{text}
{false}
[x] := y   
#{false}
\end{minted}

\textbf{Output}: 
\begin{minted}{text}
Simplified precondition:
⊥
⊥ (all branches pruned)
\end{minted}

\item 
\textbf{Input file}: 
\begin{minted}{text}
{ (-(x × 5) + (8 / 4 - x) × -x / 7 + -x + -x × -1) = 0 }
skip
\end{minted}

\textbf{Output}: 
\begin{minted}{text}
Simplified precondition:
(-x + 2) × x / -7 - x × 5 = 0
=========================
Execution from state:
x = x¹ ∧ (-x¹ + 2) × x¹ / -7 - x¹ × 5 = 0
-------------------------
x = x¹ ∧ (-x¹ + 2) × x¹ / -7 - x¹ × 5 = 0
\end{minted}

\item 
\textbf{Input file}: 
\begin{minted}{text}
{ 0 <= x ∗ 0 <= y }
(y ← y + x)⋆
# y >= 0
\end{minted}

\textbf{Output}: 
\begin{minted}{text}
Simplified precondition:
0 ≤ y ∗ 0 ≤ x
=========================
Execution from state:
x = x¹ ∧ y = y¹ ∧ 0 ≤ y¹ ∧ 0 ≤ x¹
-------------------------
x = x¹ ∧ y = y¹ ∧ -y¹ ≤ 0 ∧ -x¹ ≤ 0
\end{minted}

\item \textbf{Input file}: 
\begin{minted}{text}
{ ⊤ }
(x = 1?; y ← x) + (x = 2?; y ← x)
\end{minted}

\textbf{Output}: 
\begin{minted}{text}
Simplified precondition:
⊤
=========================
Execution from state:
⊤
-------------------------
x = x¹ ∧ x¹ = 1
-------------------------
x = x² ∧ x² = 2
-------------------------
x = x¹ ∧ y = x¹ ∧ x¹ = 1 ∧ y¹ = 1
∨ x = x² ∧ y = x² ∧ x² = 2 ∧ y² = 2
\end{minted}

\end{enumerate}

\subsection{ISL+ Examples}

\begin{enumerate}
\item 
\textbf{Input file}: 
\begin{minted}{text}
{ x = nil }
[x] := y
# { er: x = nil }
\end{minted}

\textbf{Output}: 
\begin{minted}{text}
Simplified precondition:
x = nil
=========================
Execution from state:
nil = nil¹ ∧ x = x¹ ∧ x¹ = nil¹
-------------------------
[stuck]
nil = nil¹ ∧ x = x¹ ∧ x¹ = nil¹
-------------------------
\end{minted}

\item 
\textbf{Input file}: 
\begin{minted}{text}
{ x ↦̸ }
free(x)
# {er: x ↦̸ }
\end{minted}

\textbf{Output}: 
\begin{minted}{text}
Simplified precondition:
x ↦̸
=========================
Execution from state:
x¹ ↦̸ ∧ x = x¹ ∧ ⊤
-------------------------
[error]
x¹ ↦̸ ∧ x = x¹ ∧ 
-------------------------
\end{minted}

\item 
\textbf{Input file}: 
\begin{minted}{text}
{ x ↦ v }
free(x)
# {ok: x ↦̸ }
\end{minted}

\textbf{Output}: 
\begin{minted}{text}
Simplified precondition:
x ↦ v
=========================
Execution from state:
x¹ ↦ v¹ ∧ v = v¹ ∧ x = x¹ ∧ ⊤
-------------------------
v = v¹ ∧ x = x¹ ∧ x¹ ↦̸ ∧ ⊤
\end{minted}

\item 
\textbf{Input file}: 
\begin{minted}{text}
{ x = x' }
x := alloc()
# { ok: x ↦ _ }
\end{minted}

\textbf{Output}: 
\begin{minted}{text}
Simplified precondition:
x = x¹
=========================
Execution from state:
x = x² ∧ x² = x¹
-------------------------
x = x³ ∧ x³ ↦ _ ∧ ⊤ ∧ x² = x¹
\end{minted}

\item 
\textbf{Input file}: 
\begin{minted}{text}
{ y ↦̸ }
x := alloc()
# { ok: x ↦ v ∧ x = y }
\end{minted}

\textbf{Output}: 
\begin{minted}{text}
Simplified precondition:
y ↦̸
=========================
Execution from state:
y¹ ↦̸ ∧ y = y¹ ∧ ⊤
-------------------------
x = y¹ ∧ y = y¹ ∧ y¹ ↦ _ ∧ ⊤
\end{minted}

\item 
\textbf{Input file}: 
\begin{minted}{text}
{ x = nil }
free(x)
# {er: x = nil}
\end{minted}

\item 
\textbf{Input file}: 
\begin{minted}{text}
{ ⊤ }
x ← 0;
(x ← x + 1)⋆
\end{minted}

\textbf{Output}: 
\begin{minted}{text}
Simplified precondition:
⊤
=========================
Execution from state:
⊤
-------------------------
x = x¹ ∧ x¹ = 0
-------------------------
x = x⁸ ∧ emp ∧ ⊤ ∧ x¹ = 0 ∧ x² = 1 ∧ x³ = 2 ∧ x⁴ = 3 
∧ x⁵ = 4 ∧ x⁶ = 5 ∧ x⁷ = 6 ∧ x⁸ = 7
\end{minted}

\textbf{Output}: 
\begin{minted}{text}
Simplified precondition:
x = nil
=========================
Execution from state:
nil = nil¹ ∧ x = x¹ ∧ x¹ = nil¹
-------------------------
[stuck]
nil = nil¹ ∧ x = x¹ ∧ x¹ = nil¹
-------------------------
\end{minted}

\item 
\textbf{Input file}: 
\begin{minted}{text}
{ (-(x × 5) + (8 / 4 - x) × -x / 7 + -x + -x × -1) = 0 }
skip
\end{minted}

\textbf{Output}: 
\begin{minted}{text}
Simplified precondition:
(-x + 2) × x / -7 - x × 5 = 0
=========================
Execution from state:
x = x¹ ∧ (-x¹ + 2) × x¹ / -7 - x¹ × 5 = 0
-------------------------
x = x¹ ∧ emp ∧ ⊤ ∧ (-x¹ + 2) × x¹ / -7 - x¹ × 5 = 0
\end{minted}

\end{enumerate}

\end{document}